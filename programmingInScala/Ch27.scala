object Ch27 extends App {

	//27 annotations

	//27.1
	/*There are many things you can do with a program other than compiling and running it.
	Some examples are:
	1. Automatic generation of documentation as with Scaladoc.
	2. Pretty printing code so that it matches your preferred style.
	3. Checking code for common errors such as opening a file but, on some control paths, never
	closing it.
	4. Experimental type checking, for example to manage side effects or ensure ownership properties*/
	/*Such tools are called meta-programming tools, because they are programs that take other programs as
	input. Annotations support these tools by letting the programmer sprinkle directives to the tool
	throughout their source code.

	1. A documentation generator could be instructed to document certain methods as deprecated.
	2. A pretty printer could be instructed to skip over parts of the program that have been carefully
	hand formatted.
	3. A checker for non-closed files could be instructed to ignore a particular file that has been
	manually verified to be closed.
	4. A side-effects checker could be instructed to verify that a specified method has no side effects

	The compiler understands just one feature, annotations, but it doesn't attach
	any meaning to individual annotations. Each meta-programming tool can then define and use its own
	specific annotations.
	*/

	//27.2 Syntax annotations
	/*annotations have a richer general form:
	@annot(exp_{1}, exp_{2}, ...)
	The compiler itself supports arbitrary expressions, however, so long as they type check.
	Some annotation classes can make use of this, for example, to let you refer to other variables that are in scope
	@cool val normal = "Hello"
	@coolerThan(normal) val fonzy = "Heeyyy"*/

	/*
	Internally, Scala represents an annotation as just a constructor call of an annotation classâ€”replace the
	`@' by `new' and you have a valid instance creation expression. This means that named and default
	annotation arguments are supported naturally, because Scala already has named and default arguments
	for method and constructor calls. One slightly tricky bit concerns annotations that conceptually take
	other annotations as arguments, which are required by some frameworks. You cannot write an
	annotation directly as an argument to an annotation, because annotations are not valid expressions. In
	such cases you must use `new' instead of `@', as illustrated here:
	scala> import annotation._

	import annotation._

	class strategy(arg: Annotation) extends Annotation
	class delayed extends Annotation

	@strategy(@delayed) def f() = {} //err

	strategy(new delayed) def f() = {} //ok
	*/

	//27.3 Standard annotations
	//@deprecated
	//volatile
	/*The @volatile annotation helps in such cases. It informs the compiler that the variable in question will
	be used by multiple threads. Such variables are implemented so that reads and writes to the variable are
	slower, but accesses from multiple threads behave more predictably*/


	//binary serialization
	/*Instead, you should use a framework from your
	underlying platform. What Scala does is provide three annotations that are useful for a variety of
	frameworks

	The first annotation indicates whether a class is serializable at all. Most classes are serializable, but not
	all. A handle to a socket or GUI window, for example, cannot be serialized. By default, a class is not
	considered serializable. You should add a @serializableannotation to any class you would like to be
	serializable.

	The second annotation helps deal with serializable classes changing as time goes by. You can attach a
	serial number to the current version of a class by adding an annotation like@SerialVersionUID(1234),
	where 1234 should be replaced by your serial number of choice. The framework should store this
	number in the generated byte stream. When you later reload that byte stream and try to convert it to an
	object, the framework can check that the current version of the class has the same version number as
	the version in the byte stream. If you want to make a serialization-incompatible change to your class,
	then you can change the version number. The framework will then automatically refuse to load old
	instances of the class.

	Finally, Scala provides a @transient annotation for fields that should not be serialized at all. If you
	mark a field as @transient, then the framework should not save the field even when the surrounding
	object is serialized. When the object is loaded, the field will be restored to the default value for the type
	of the field annotated as @transient.*/

	//automatic get and set
	//@BeanProperty
	//tailrec
	/*You would typically add the @tailrec annotation to a method that needs to be tail recursive, for instance
	because you expect that it would recurse very deeply otherwise.*/
	//unchecked
	//to supress exhaustivity warnings in during pattern matching
	//native
	/*The @native annotation informs the compiler that a method's implementation is supplied by the
	runtime rather than in Scala code. The compiler will toggle the appropriate flags in the output, and it
	will be up to the developer to supply the implementation using a mechanism such as the Java Native
	Interface (JNI).*/
	/*When using the @native annotation, a method body must be supplied, but it will not be emitted into the
	output. For example, here is how to declare that method beginCountdown will be supplied by the
	runtime:*/
	//@native
	//def beingCountDown() = {???}

}